---
title: "glasso_paco"
format: pdf
header-includes: 
- \usepackage{booktabs}
- \usepackage{longtable}
---

```{r}
#| label: setup
#| include: false
#| eval: true

# author: kat 
# date: 07/15/2025
# purpose: fit graphical lasso to create network visualization of partial 
#              correlations between biomarkers by treatment group


knitr::opts_chunk$set(eval=TRUE
                      , echo=FALSE
                      , message=FALSE
                      , warning=FALSE)
#rm(list=ls())

library(readxl)
library(tidyverse)
library(gtsummary)
library(kableExtra)
library(igraph)
library(ggraph)
library(tidygraph)
library(ggpubr)
library(glasso)

options(knitr.kable.NA = '--')
```

```{r}
#| label: import-dat

paco <- read_excel("Data/data for Kat.xlsx")

# define which biomarkers to include
biomarkers <- paco |>
  select(ends_with("pg_ml"), shbg_nmol_l, "p4_ng_ml") |>
  colnames()

# exclude e2_ng_ml b/c be2 is included (and derived from e2) - see email from Lena on 7/15 

# define which placental outcomes to include (separate networks for each)
placenta_outcomes <- c("villous_surface_density"
                       , "villous_volume"
                       , "bwc"          # need updated data from Lisa
                       , "pw_centile"   # need updated data from Lisa
                       , "bw_pw_ratio") # need updated data from Lisa

outc_labels <- c("Villous Surface Density"
                 , "Villous Volume")
```


```{r}
#| label: glasso-func
#| include: false

#ggplot(data=paco, aes(x=villous_surface_density)) + geom_density()
#ggplot(data=paco, aes(x=villous_volume)) + geom_density()

get_pcorr <- function(outc,grp, rho_param){
  
  all_vars <- c(biomarkers, placenta_outcomes[outc])
 
  # (1.) compute covariance matrix
  if (is.na(grp)){
    dat <- paco |>
      select(all_of(all_vars)) |>
      # Need to do case-wise deletion (remove completely if missing one value)
      # because need to give a single sample size in glasso function
      na.omit()
  } else {
    dat <- paco |>
      filter(treatment == grp) |>
      select(all_of(all_vars)) |>
      # Need to do case-wise deletion (remove completely if missing one value)
      # because need to give a single sample size in glasso function
      na.omit()
  }  
  
  covmat <- dat |>
    scale() |>
    as_tibble() |>
    cov(use="complete.obs") 
  
  print(nrow(dat))
  
  # (2.) fit model using glasso function
  # from https://cran.r-project.org/web/packages/glasso/glasso.pdf
  # s - Covariance matrix:p by p matrix (symmetric)
  
  # rho (Non-negative) - regularization parameter for lasso. rho=0 means no 
  #regularization. Can be a scalar (usual) or a symmetric p by p matrix, or a vector #of 
  # length p. In the latter case, the penalty matrix has jkth element sqrt(rho[j]*rho[k]).
  
  # nobs - Number of observations used in computation of the covariance matrix s. This
  #quantity is need to compute the value of log-likelihood. If not specified, loglik
  #will be returned as NA.
  
  glasso_fit <- glasso(s = covmat
                   # set to NO regularization to start
                   # later use cross-validation to choose the reg. param.?
                   # this returns all nonzero covariance params because
                   # no regularization . . .
                   , rho = rho_param
                   , nobs = nrow(dat))

  # (3.) compute the partial correlation from the glasso function output
  # glasso documentation says this function returns:
  # w - Estimated covariance matrix  
  # wi - Estimated inverse covariance matrix
  # loglik - Value of maximized log-likelihood+penalty

  # https://en.wikipedia.org/wiki/Partial_correlation

  n_vars <- length(all_vars)
  inv_sig <- glasso_fit$wi
  variance_diag <- diag(diag(inv_sig), n_vars, n_vars)
  
  # https://online.stat.psu.edu/stat505/book/export/html/638
  # https://kongres2025.stat.gov.pl/Content/Docs/Prezentacje/Sess3/01%20-%20mbogdan.pdf
  # (slide 37)
  pcorrs <- -sqrt(solve(variance_diag)) %*% inv_sig %*% sqrt(solve(variance_diag))
  print(pcorrs)
  
  # (4.) Create the network object
  colnames(pcorrs) <- all_vars
  pcorrs_network0 <- pcorrs |>
    as_tibble() |>
    mutate(var1 = all_vars) |>
    pivot_longer(cols=-var1, names_to="var2", values_to="pcorr") |>
    filter(var1 < var2) |>
    # remove edges where the partial corr has been reduced to 0
    filter(pcorr != 0)
  
  print(min(pcorrs_network0$pcorr))
  print(max(pcorrs_network0$pcorr))
  
  pcorrs_network <- pcorrs_network0 |>
    # Y is not a node in the graph; rather each biomarker's node will
    # be colored/sized by its partial correlation with Y (so any correlations)
    # with Y are node attributes, NOT edge attributes)
    filter(var1 != placenta_outcomes[outc] & var2 != placenta_outcomes[outc]) |>
    as_tbl_graph(directed = FALSE) |>
    activate(nodes) |>
    left_join(pcorrs_network0 |>
                filter(var1 == placenta_outcomes[outc] | 
                         var2 == placenta_outcomes[outc]) |>
                select(var1, pcorr_outcome=pcorr)
              , by=c("name"="var1")) |>
    mutate(name_short = str_extract(name, "[^_]+"))

  # (5.) Create the network visualization 
  pcorrs_viz <- ggraph(pcorrs_network) + 
    geom_edge_link(aes(edge_color = pcorr
                       , edge_width = abs(pcorr))) + #, edge_alpha = 0.8, ) + 
    geom_node_point(aes(size = abs(pcorr_outcome)
                        , color = pcorr_outcome
                        , shape = (pcorr_outcome > 0))
                    , show.legend = FALSE) +
    geom_node_text(aes(label = name_short), repel = TRUE) +
    # Had to add `base_family` argument due to error with fonts loading for PDF
    theme_graph(base_family = "sans"
                , caption_size = 10) +
    theme(legend.key.width = unit(2, "cm")) +
    #labs(title=paste0(outc_labels[outc], ": ", grp)) +
    #labs(title=outc_labels[outc]) +
    labs(caption=grp) +
    scale_edge_width(guide="none") +
    scale_color_distiller(palette="BrBG" #palette="RdYlGn" 
                          , direction=1
                          , limits=c(-0.8, 0.8)
                          , breaks=c(-0.8, -0.4, -0.1, 0.1, 0.4, 0.8)) +
    scale_edge_color_distiller(palette="BrBG" #palette="RdYlGn" 
                               , direction=1
                               , limits=c(-0.8, 0.8)
                               , breaks=c(-0.8, -0.4, -0.1, 0.1, 0.4, 0.8)) +
    scale_shape_manual(values=c(15, 16))

  return(pcorrs_viz)
}

```

<!-- # No regularization (penalty=0), all edges realized-->

```{r}
#| label: glasso-testing-noreg
#| include: false
#| eval: false

plot_vsd_ctrl <- get_pcorr(outc=1, grp="Control", rho_param=0) # n = 40
plot_vsd_INSTI <- get_pcorr(outc=1, grp="INSTI", rho_param=0)   # n = 19
plot_vsd_PrEP <- get_pcorr(outc=1, grp="PrEP", rho_param=0)    # n = 27

plot_vv_ctrl <- get_pcorr(outc=2, grp="Control", rho_param=0) # n = 40
plot_vv_INSTI <- get_pcorr(outc=2, grp="INSTI", rho_param=0)   # n = 19
plot_vv_PrEP <- get_pcorr(outc=2, grp="PrEP", rho_param=0)    # n = 27


# since no regularization, should just equal the partial correlation.
# but they don't seem to be ... hmmm ... some very off ...
# NOW THE NUMBERS MATCH IF DO THE computation
# sqrt(solve(vars_vsd)) %*% inv_sig %*% sqrt(solve(vars_vsd))
# where inv_sig is the glasso wi output
# BUT THE SIGNS ARE EXACTLY THE OPPOSITE?! WHY!?
test_ctrl <- paco |>
  filter(treatment == "Control") |>
  select(all_of(biomarkers), placenta_outcomes[1]) |>
  na.omit()

print("Partial Correlations from pcor function in ppcor package - control grp:")
ppcor::pcor(test_ctrl)

test_insti <- paco |>
  filter(treatment == "INSTI") |>
  select(all_of(biomarkers), placenta_outcomes[1]) |>
  na.omit()

print("Partial Correlations from pcor function in ppcor package - INSTI grp:")
ppcor::pcor(test_insti)
```

```{r}
#| label: glasso-noreg-plots
#| fig-width: 7
#| fig-height: 10
#| eval: false

ggarrange(plot_vsd_ctrl, plot_vsd_INSTI, plot_vsd_PrEP
          , nrow = 3
          , common.legend = TRUE
          , legend = "right"
          , labels = c(outc_labels[1], "", ""))

ggarrange(plot_vv_ctrl, plot_vv_INSTI, plot_vv_PrEP
          , nrow = 3
          , common.legend = TRUE
          , legend = "right"
          , labels = c(outc_labels[2], "", ""))
```

```{r}
#| label: glasso-fits
#| include: false

rho_values <- c(0, 0.01, 0.05, 0.1, 0.2, 0.25)

control_vsd <- list()
insti_vsd <- list()
prep_vsd <- list()

control_vv <- list()
insti_vv <- list()
prep_vv <- list()

for (r in rho_values){
  
  # ---------------------------- VSD 
  
  control_vsd[[which(rho_values==r)]] <- get_pcorr(outc=1, grp="Control", rho_param=r) +
    labs(subtitle=paste("rho =",r))
  
  insti_vsd[[which(rho_values==r)]] <- get_pcorr(outc=1, grp="INSTI", rho_param=r) +
    labs(subtitle=paste("rho =",r))
  
  prep_vsd[[which(rho_values==r)]] <- get_pcorr(outc=1, grp="PrEP", rho_param=r) +
    labs(subtitle=paste("rho =",r))
  
  # ---------------------------- VV
  
  control_vv[[which(rho_values==r)]] <- get_pcorr(outc=2, grp="Control", rho_param=r) +
    labs(subtitle=paste("rho =",r))
  
  insti_vv[[which(rho_values==r)]] <- get_pcorr(outc=2, grp="INSTI", rho_param=r) +
    labs(subtitle=paste("rho =",r))
  
  prep_vv[[which(rho_values==r)]] <- get_pcorr(outc=2, grp="PrEP", rho_param=r) +
    labs(subtitle=paste("rho =",r))
}

```

# VSD - Control group, with different penalties 

```{r}
#| label: glasso-vsd-control
#| fig-width: 8
#| fig-height: 11

ggarrange(control_vsd[[1]], control_vsd[[2]], control_vsd[[3]]
          , control_vsd[[4]], control_vsd[[5]], control_vsd[[6]]
          , common.legend = TRUE, legend="bottom"
          , nrow=3, ncol=2
          , labels = c(outc_labels[1], "", "", "", "", ""))

```

# VSD - INSTI group, with different penalties 

```{r}
#| label: glasso-vsd-insti
#| fig-width: 8
#| fig-height: 11

ggarrange(insti_vsd[[1]], insti_vsd[[2]], insti_vsd[[3]]
          , insti_vsd[[4]], insti_vsd[[5]], insti_vsd[[6]]
          , common.legend = TRUE, legend="bottom"
          , nrow=3, ncol=2
          , labels = c(outc_labels[1], "", "", "", "", ""))

```

# VSD - PrEP group, with different penalties 

```{r}
#| label: glasso-vsd-prep
#| fig-width: 8
#| fig-height: 11

ggarrange(prep_vsd[[1]], prep_vsd[[2]], prep_vsd[[3]]
          , prep_vsd[[4]], prep_vsd[[5]], prep_vsd[[6]]
          , common.legend = TRUE, legend="bottom"
          , nrow=3, ncol=2
          , labels = c(outc_labels[1], "", "", "", "", ""))

```

# VV - Control group, with different penalties 

```{r}
#| label: glasso-vv-control
#| fig-width: 8
#| fig-height: 11

ggarrange(control_vv[[1]], control_vv[[2]], control_vv[[3]]
          , control_vv[[4]], control_vv[[5]], control_vv[[6]]
          , common.legend = TRUE, legend="bottom"
          , nrow=3, ncol=2
          , labels = c(outc_labels[2], "", "", "", "", ""))

```

# VV - INSTI group, with different penalties 

```{r}
#| label: glasso-vv-insti
#| fig-width: 8
#| fig-height: 11

ggarrange(insti_vv[[1]], insti_vv[[2]], insti_vv[[3]]
          , insti_vv[[4]], insti_vv[[5]], insti_vv[[6]]
          , common.legend = TRUE, legend="bottom"
          , nrow=3, ncol=2
          , labels = c(outc_labels[2], "", "", "", "", ""))

```

# VV - PrEP group, with different penalties 

```{r}
#| label: glasso-vv-prep
#| fig-width: 8
#| fig-height: 11

ggarrange(prep_vv[[1]], prep_vv[[2]], prep_vv[[3]]
          , prep_vv[[4]], prep_vv[[5]], prep_vv[[6]]
          , common.legend = TRUE, legend="bottom"
          , nrow=3, ncol=2
          , labels = c(outc_labels[2], "", "", "", "", ""))

```
